'use strict';

const querystring     = require('querystring');
const http            = require('http');
const headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Cookie': 'username=api; utoken=manager;',
};


// Authentication Middleware
module.exports.authenticationMiddleware = function authenticationMiddleware(req, res, next){
    const integration                   = req.swagger.operation["x-apigateway-integration"];
    const authorizationHeaderRaw        = req.header("Authorization");
    const authorizationHeaderDecoded    = decodeBase64AuthenticationToken(authorizationHeaderRaw);
    const authorizationHeader           = querystring.stringify(authorizationHeaderDecoded);
    return new RequestChain(req).process([
        [
            {
                hostname:   integration.hostname,
                port:       integration.port,
                path:       "/login",
                method:     "POST",
                headers:    headers,
                write:      authorizationHeader
            },
            function(data){
                if (data.success) {
                    next();
                } else {
                    sendErrorResponse(new Error("Unauthenticated"), 403)
                }
            }
        ]
    ]);
};

// Gateway Middleware to Map Request Endpoints to Pure Access Endpoints
module.exports.gatewayMiddleware = function gatewayMiddleware(req, res, next){
    try {
        const integration                   = req.swagger.operation["x-apigateway-integration"];
        const authorizationHeaderRaw        = req.header("Authorization");
        const authorizationHeaderDecoded    = decodeBase64AuthenticationToken(authorizationHeaderRaw);
        const authorizationHeader           = querystring.stringify(authorizationHeaderDecoded);
        return new RequestChain(req).process([
            [
                {
                    hostname    :   integration.hostname,
                    port        :   integration.port,
                    path        :   "/getTenantForUser?" + authorizationHeader,
                    method      :   "GET",
                    headers     :   headers,
                },
                function(data){
                    return data;
                }
            ],
            [
                {
                    hostname    :   integration.hostname,
                    port        :   integration.port,
                    method      :   convertMethod(integration.httpMethod),
                    headers     :   headers,
                    fn: function(data){ // Function for Processing Header Fields Based on the Returned Values from the Previous Request (/getTenantForUser)
                        const tenantId  = data.result.id;
                        this.write      = getParams(req.swagger.params, data.result.id);
                        this.path       = integration.path;
                        switch (integration.httpMethod){
                            case "GET":
                                this.path = integration.path + "?" + getParams(req.swagger.params, tenantId);
                                break;
                        }
                        return data;
                    }
                },
                function(data) {
                    if (data.success) {
                        res.data = data;
                        next();
                    } else {
                        sendErrorResponse(new Error("Unauthenticated"), 403)
                    }
                    return data;
                }
            ]
        ]);
    } catch (e) {
        next(e);
    }
};

// Parse the Result and Populate Fields
module.exports.postFormatMiddleware = function postFormatMiddleware(req, res, next){
    const requestChain  = new RequestChain(req);
    const integration   = req.swagger.operation["x-apigateway-integration"];
    const isArray       = res.examples.constructor === Array;
    var examples        = res.examples;
    var result          = res.data.result;

    var callback = function(resource){
        var model = isArray ? res.examples[0] : res.examples;
        return new ResourceConverter(resource, model, requestChain).preformat();
    };

    var finalCallback = function (data) {
        res.end(JSON.stringify(data));
    }


    try {
        // Array of Results
        if (isArray){
            processArray(result, callback).then(finalCallback);
        }
        // Single Result
        else {
            callback(result).then(finalCallback);
        }
    } catch (e) {
        sendErrorResponse(res, e); // TODO: Change Response Code
    }
};


///////////////////////////////////////
// Convenience Classes and Functions //
///////////////////////////////////////

// Throws Errors Specific to Requests and Responses
class RequestChain {
    constructor(req){
        this.req            = req;
        this.integration    = req.swagger.operation["x-apigateway-integration"];
    }

    //Sequential Promise Resolution
    process(requestArray){
        var self = this;
        requestArray.reduce(
            function(promise, request){
                return promise.then(
                    function(result){
                        const options = request[0];
                        const callback = request[1];
                        if (options.hasOwnProperty("fn")) {
                            options.fn(result[result.length-1]);
                        }
                        return self.makeRequest(options)
                            .then(callback)
                            .then(
                                Array.prototype.concat.bind(result) // Process Data and Append it To List;
                            );
                    }
                );
            },
            Promise.resolve([])
        )
    }

    // Convenience Function to Make Requests to the Pure Access
    makeRequest(options) {
        var body = "";
        return new Promise(function(resolve, reject){
            const request = http.request(options, (response) => {
                response.setEncoding(options.encoding ? options.encoding : 'utf8');
                response.on('data', (chunk) => {
                    // console.log(`BODY: ${chunk}`);
                    if (options.encoding === "binary"){
                        body += new Buffer(chunk, 'binary').toString('hex');
                    } else {
                        body += chunk;
                    }
                });
                response.on('end', function(t){
                    var result;
                    try {
                        if (options.encoding === "binary"){
                            var fileExtension = response.headers['content-disposition'].replace(/.+\./, '');
                            var b64String= new Buffer(body, 'hex').toString('base64');
                            result = "data:image/" + fileExtension + ";base64," + b64String;
                        } else {
                            result = JSON.parse(body);
                        }
                    } catch (e) {
                        reject(e.toString());
                    }
                    resolve(result);
                });
            });
            request.on('error', (e) => {
                console.error(`Problem with Request: ${e.message}`);
                reject();
            });
            if (options.write){
                request.write(options.write)
            }
            request.end();
        });
    }

    getImage(profileId){
        var self = this;
        return this.makeRequest(
            {
                hostname:   self.integration.hostname,
                port:       self.integration.port,
                path:       "/attachment?id=" + profileId,
                method:     "GET",
                headers:    headers,
                encoding:   "binary"
            }
        )
            .catch(
                function(e){
                    reject(e);
                }
            )
            .then(
                function(data){
                    self.resource["image"] = data;
                    resolve(self.resource);
                }
            );
    }
}

function sendErrorResponse(res, e) {
    res.status(499).send(JSON.stringify({"message": e.message})); // TODO: Change Response Code
}

function convertMethod(method){
    switch (method){
        case "GET":
            return "GET";
        case "POST":
        case "PATCH":
        case "PUT":
            return "POST";
    }
}

function processArray(array, callback){
    var resultPromises = array.map(
        function(item){
            return callback(item);
        }
    );
    return Promise
        .all(resultPromises)
        .then(
            function(result){
                return result;
            }
        )
}

function getParams(params, tenantId){
    try {
        var result = {};
        var extra = "";
        Object.keys(params).forEach(function(param){
            result[param] = params[param].value;
            if (typeof result[param] === "object"){
                extra += querystring.stringify(result[param]);
                delete result[param];
            }
        });
        result.tenantId = tenantId;
        return querystring.stringify(result) + "&" + extra;
    } catch (e) {
        throw new Error("Couldn't Get Params");
    }
}

function decodeBase64AuthenticationToken(b64String){
    try {
        const strippedString = b64String.replace("Basic", "").replace(" ", "");
        const decoded = new Buffer(strippedString, 'base64').toString();
        const username = decoded.replace(/:.+/, "");
        const password = decoded.replace(/.+:/, "");
        return {username: username, pwd: password};
    } catch (e) {
        return {username:"", pwd: ""}
    }
}


// Traverse the JSON Response and Find Required Fields
function findNode(key, currentNode, maxDepth) {
    var i,
        currentChild,
        result;
    if (maxDepth <= 0) {
        return false;
    }
    if (currentNode.hasOwnProperty(key)) {
        return currentNode[key];
    } else {
        // Use a for loop instead of forEach to avoid nested functions
        // Otherwise "return" will not work properly
        for (i = 0; i < Object.keys(currentNode).length; i += 1) {
            currentChild = currentNode[Object.keys(currentNode)[i]];
            if (currentChild === null) {
                continue;
            }
            // Search in the current child
            result = findNode(key, currentChild, maxDepth - 1);
            // Return the result if the node has been found
            if (result !== false) {
                return result;
            }
        }
        // The node has not been found and we have no more options
        return false;
    }
}

class ResourceConverter {
    constructor(resource, model, requestChain){
        this.resource       = resource;
        this.model          = model;
        this.requestChain   = requestChain;
        this.prune();
        this.normalize();
    }

    // Removes Properties not in Model from the Resource
    prune(){
        var self = this;
        Object.keys(self.resource).forEach(
            function(key){
                if (self.model[key] === undefined) {
                    delete self.resource[key];
                }
            }
        )
    }

    // Adds Properties not Found in the Original Resources, but the Ones Specified in Model
    normalize(){
        var self = this;
        Object.keys(self.model).forEach(
            function(key){
                if (self.resource[key] === undefined) {
                    self.resource[key] = null;
                }
            }
        )
    }

    preformat(){
        var self = this;
        var promises = [];

        Object.keys(self.model).forEach(
            function(field){
                switch (field){
                    case "profileId":
                        //result[property] = req.swagger.swaggerObject.host + "/attachment?id=" + result[property]; // Make Request to get the Octet Stream Here
                        promises.push(self.requestChain.getImage(self.resource[field]));
                        break;
                    default:
                        promises.push(Promise.resolve(self.resource));
                        break;
                }
            }
        );
        return Promise.all(promises);
    }
}


